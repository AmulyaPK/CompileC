%option yylineno
%{
/*
  lexer.l
  Robust C-ish lexical analyser for use with the parser (parser.y).
  Sets yylval.str for IDENTIFIER, NUMBER, FLOAT_CONST, STRING_LITERAL, CHAR_LITERAL, PREPROCESSOR, INCLUDE.
  Handles nested comments, string/char escapes, header includes.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include "hello.tab.h"   /* generated by bison -d parser.y; contains token definitions */

extern YYSTYPE yylval;   /* Bison semantic value */
extern int yylineno;
static char *dup_text(const char *s){ if(!s) return NULL; char *r = malloc(strlen(s)+1); if(!r){perror("malloc");exit(1);} strcpy(r,s); return r; }
%}

/* macros */
HEX     0[xX][0-9a-fA-F]+
OCT     0[0-7]+
DEC     ([1-9][0-9]*|0)
INTLIT  ({HEX}|{OCT}|{DEC})
EXP     ([eE][+-]?[0-9]+)
FLOAT1  ([0-9]+\.[0-9]*{EXP}?|[0-9]+{EXP})
FLOAT2  (\.[0-9]+{EXP}?)
FLOATLIT ({FLOAT1}|{FLOAT2})
ID      [A-Za-z_][A-Za-z0-9_]*
WS      [ \t\v\f\r]+
NL      \n

/* string/char bodies */
CHAR_BODY   ([^\\'\n]|\\.)
STR_BODY    ([^\\\"\n]|\\.)

%%

{NL}                        { }
{WS}                        { /* ignore */ }

"include"[ \t]+\"[A-Za-z0-9_./-]+\"    { yylval.str = dup_text(yytext); return INCLUDE; }
\#[ \t]*include[ \t]*\<[A-Za-z0-9_./-]+\> {
                               yylval.str = dup_text(yytext);
                               return INCLUDE; }
\#[ \t]*[a-zA-Z_][a-zA-Z0-9_]*(.*)     {
                               yylval.str = dup_text(yytext);
                               return PREPROCESSOR;
                             }

"<"[A-Za-z0-9_./-]+">"       { yylval.str = dup_text(yytext); return HEADER; }
\"[A-Za-z0-9_./-]+\"         { yylval.str = dup_text(yytext); return HEADER; }

"auto"|"const"|"break"|"goto"|"continue"|"switch"|"case"|"do"|"default"|"double"  { return KEYWORD; }
"register"|"static"|"while"|"volatile"|"extern"|"short"|"unsigned"|"signed"      { return KEYWORD; }
"int"|"char"|"float"|"void"|"bool"|"for"|"return"|"sizeof"|"struct"|"union"|"typedef"|"if"|"else" { return KEYWORD; }

{ID}                        {
                              yylval.str = dup_text(yytext);
                              return IDENTIFIER;
                            }
{HEX}                       { yylval.str = dup_text(yytext); return INT_CONST; }
{OCT}                       { yylval.str = dup_text(yytext); return INT_CONST; }
{DEC}                       { yylval.str = dup_text(yytext); return INT_CONST; }
{FLOATLIT}                  { yylval.str = dup_text(yytext); return FLOAT_CONST; }
([0-9]+){EXP}               { yylval.str = dup_text(yytext); return FLOAT_CONST; }

\'{CHAR_BODY}\'             {
                              yylval.str = dup_text(yytext);
                              return CHAR_CONST;
                            }
\'([^\\'\n]|\\.)*           { fprintf(stderr,"ERR_INCOMPLETE_CHAR: Line %d near %s\n", yylineno, yytext); return UNMATCHEDCHAR; }
\"{STR_BODY}*\"             {
                              yylval.str = dup_text(yytext);
                              return STRING_LITERAL;
                            }
\"([^\\\"\n]|\\.)*          { fprintf(stderr,"ERR_INCOMPLETE_STRING: Line %d near %s\n", yylineno, yytext); return UNMATCHEDSTRING; }

"++"|"--"|"->"              { return INCDEC; }
"+="|"-="|"*="|"/="|"%="    { return ASSIGN; }
"=="|"!="|">="|"<="         { return RELOP; }
"&&"|"||"                   { return LOGIC_OP; }
"<"|">"|"="|"+"|"-"|"*"|"/"|"%"|"!"|"~"|"&"|"|"|"^"  { return OP; }

"{"                         { return LBRACE; }
"}"                         { return RBRACE; }
"("                         { return LPAREN; }
")"                         { return RPAREN; }
"["                         { return LBRACK; }
"]"                         { return RBRACK; }
";"                         { return SEMI; }
","                         { return COMMA; }
":"                         { return COLON; }
"."                         { return DOT; }
"?"                         { return QMARK; }

"//".*                      { /* ignore single line comment */ }
"/*"([^*]|\*+[^*/])*\*+"/"   { /* ignore block comments */ }


. {
    fprintf(stderr,"ERR_UNEXPECTED_CHARACTER: Line %d near '%s'\n", yylineno, yytext);
    /* do not return â€” just skip */
}

%%

int yywrap() {
    return 1;  // Returning 1 tells Lex that scanning is finished
}
